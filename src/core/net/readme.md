文件结构说明：

```
        sis_net.mem.c 数据交换  
        sis_net.mem.h 数据交换  
        sis_net.dp.c 网络层  
        sis_net.dp.h 网络层  
    sis_net.ws.c  协议层  
    sis_net.ws.h  协议层  
    sis_net.rds.c 协议层  
    sis_net.rds.h 协议层  
sis_net.node.c 应用层  
sis_net.node.h 应用层  
```

sis_net.c   提供给外部用户访问的函数定义
sis_net.h   提供给外部用户访问的接口和类型

### 通讯包关键字

| 关键字  |  请求  |  应答  | 说明                                              |
| :------ | :----: | :----: | :------------------------------------------------ |
| sno     | 非必要 | 非必要 | 是否带包序号 为64位整数 递增号                    |
| service |  必要  | 非必要 | 服务名 寻找哪个服务 service                       |
| cmd     |  必要  | 非必要 | 指令名 寻找该服务下的哪个命令                     |
| subject | 非必要 | 非必要 | 主体名                                            |
| tag     | 非必要 |  必要  | 指明数据包的类型 0 表示成功 其他表示各种信息      |
| info    | 非必要 | 非必要 | 附属信息                                          |
| more    | 非必要 | 非必要 | 是否有扩展数据 扩展字段存储为 (klen+key+vlen+val) |
| mark    |  固定  |  固定  | 做记号 == 1 以区分JSON字符串                      |

#### more 可能的扩展信息

| 关键字 | 适用范围 | 说明                 |
| :----- | :------: | :------------------- |
| #link  |   通用   | 分级传输时的链路信息 |
| #page  |   通用   | 分页传输时的页面信息 |
| ....   |   通用   |                      |

#### 多进程通讯

    监听指定端口
    接收信息 并更新到共享内存
    主进程负责定时把共享内存数据广播同步出去，保证单机同时只有一个进程同步状态
    次进程同步自己的信息到共享内存 start stop status 等状态信息
    所有网络服务的进程 动态绑定通讯端口 端口默认为偶数 默认一个服务一个端口
    默认服务的接口层是单线程 简化底层的故障概率
    请求客户端直接连接空闲的对手服务 发送请求后 根据服务名+端口找到对应实例的函数 调用后返回数据

    主进程挂了 次进程升级为主进程 此时需要强制检查一次所有服务是否健壮 然后清理掉挂的那个服务 再广播给网络 由网络的监控服务记录该次事故
    请求客户端连接的服务如果挂掉，需要返回disconnect信息和回调

<!-- | crc      |  通用 |  数据校验 crc16 crc32
   | fmt    |  随msg  | 随msg   |  msg格式 0 字符 1 表示有描述msg的数据格式 可能二进制、压缩、加密等
   | encrypt  |  通用 |  加密算法 sha256 rsa128
   | decrypt  |  通用 |  解密算法 sha256 rsa128
   | compress |  通用 |  压缩算法 snappy -->

#### tag 预定义信息

|   值 | 定义                  | 说明                                       | info 可能值     |
| ---: | :-------------------- | :----------------------------------------- | :-------------- |
| -100 | SIS_NET_TAG_INVALID   | 请求已经失效                               | STRING          |
|   -3 | SIS_NET_TAG_NIL       | 请求的数据为空                             | STRING          |
|   -2 | SIS_NET_TAG_ERROR     | 未知原因错误 msg中可能存放字符串的错误原因 | STRING          |
|   -1 | SIS_NET_TAG_NOAUTH    | 未登录验证                                 | STRING          |
|    0 | SIS_NET_TAG_OK        | 数据正确 通常表示为请求完成的应答          | NULL            |
|    1 | SIS_NET_TAG_INT       | 返回整数 二进制64位整数                    | INT64           |
|    2 | SIS_NET_TAG_JSON      | 返回JSON字符串                             | STRING          |
|    3 | SIS_NET_TAG_ARRAY     | 返回ARRAY字符串                            | STRING          |
|    4 | SIS_NET_TAG_CHAR      | 返回字符串 字符串                          | STRING          |
|    5 | SIS_NET_TAG_CHARS     | 返回字符串列表 count+[size+data]           | CHARS           |
|    6 | SIS_NET_TAG_BYTE      | 返回二进制 数据流                          | DATA            |
|    7 | SIS_NET_TAG_BYTES     | 返回二进制列表 count+[size+data]           | DATAS           |
|  100 | SIS_NET_TAG_SUB_OPEN  | 订阅打开 字符串日期                        | DATE            |
|  101 | SIS_NET_TAG_SUB_KEY   | 订阅时返回的键值 START 时初始化 然后递增   | 逗号分隔 STRING |
|  102 | SIS_NET_TAG_SUB_SDB   | 订阅是返回的结构 START 时初始化 然后递增   | JSON            |
|  103 | SIS_NET_TAG_SUB_START | 订阅开始 字符串日期                        | DATE            |
|  104 | SIS_NET_TAG_SUB_WAIT  | 订阅缓存数据结束 等待新的数据 字符串日期   | DATE            |
|  105 | SIS_NET_TAG_SUB_STOP  | 订阅结束 字符串日期                        | DATE            |
|  106 | SIS_NET_TAG_SUB_CLOSE | 订阅关闭 字符串日期                        | DATE            |

#### tag 预定义信息

|  100 | SIS_NET_TAG_MSG_SET   | 此数据为信息包 下级连接按接收顺序传递 数据流      | DATA        |
|  101 | SIS_NET_TAG_MSG_PUB   | 此数据为广播包 下级连接直接广播 数据流            | DATA        |

#### 二进制数据包的末尾 有一个字节的标志位

| 关键字   | 位长 | 值域  | 说明                |
| :------- | :--- | :---- | :------------------ |
| -        | -    | -     | 0 - 原始二进制数据  |
| crc16    | 1    | 0..1  | 是否有crc16数据校验 |
| compress | 3    | 0..7  | 7种压缩方式         |
| 6..7     | 4    | 0..15 | 15种加密方式        |

//////////////////////////////////////////////////////////////////////////////////////////
// 对于 json 格式请求和应答
// 例子 :
// { service: auth, cmd:login, msg : {ver: 1.0, name:guest, password: guest1234}}
//     默认格式为JSON字符串返回数据 需要支持二进制转BASE64 GBK格式字符串转UTF8才能写入返回数据
//     如果是二进制返回 有什么数据写入什么数据
//
// 任何时候的命令 如果带了
// service:sisdb, cmd:create, subject: info, msg:{fields:{...}}
// service:sisdb, cmd:set, subject: sh600600.info, msg:{{...}}
// service:sisdb, cmd:get, subject: sh600600.info, msg:{ fmt: json, fields:{...}}
//     fmt : json  以json格式返回数据
//     fmt : csv   以csv格式返回数据
//     fmt : array 以array格式返回数据
//     fmt : bytes 以二进制格式返回数据
//     fmt : incr  以压缩格式返回数据
// service:sisdb, command:sub, subject: sh600600.*, msg:{ sub-date: 20200101}

//////////////////////////////////////////////////////////////////////////////////////////
// 对于 二进制 格式请求和应答
// name: + 数据 (name为空时只有而且必须有冒号) 方便数据快速发布和传递
// fmt体现在数据区的第一个字符 除B,J,H外暂不支持其他字符
// *** 首字符为 B | 二进制格式
// *** 首字符为 { | JSON格式
// *** 首字符为 H ｜ HTTP格式 ..... 或者redis首字符为R
// name不压缩以 : 分隔 方便数据广播
// 一个字节表示 具备哪些字符
// ｜ 0 1 2 3 4 5 6 7 ｜
//  0 --> 0 无扩展字段  1 表示有扩展字段
//  1 --> 0 表示请求   1 表示应答
//  10000000   -- > 是否有扩展字段 如果为 1 表示有扩展字段 后面跟1个字节表示扩展字段的个数
//  01000000   -- > 应答包标记 - 表示该数据包为应答 如果其他字段都为0表示OK
// ----------------------------  //
//    000000   -- > 二进制数据 size + data
//    000001   -- > 有 ver 字段
//    000010   -- > 有 command
//    000100   -- > 有 service
//    001000   -- > 有 ask 字段
//    010000   -- > 有 fmt 字段  // 只有请求包有该字段 要求返回的数据格式
//    100000   -- > 有 lnk 字段  // 表示来源路径 需要一级一级返回
// ----------------------------  //
//    000000   -- > 二进制数据 size+data
//    000001   -- > 有 ver 字段
//    000010   -- > 有 ans 字段
//    000100   -- > 有 msg 字段
//    001000   -- > 有 fuc 字段
//    010000   -- > 备用
//    100000   -- > 有 lnk 字段  // 表示返回路径 需要一级一级返回

//  标准字段读完后 就需要读扩展字段 扩展字段最多255个
//  标准字段格式 直接为数据区大小+数据区
//  扩展字段格式 字段大小+字段名 数据区大小+数据区
//////////////////////////////////////////////////////////////////////////////////////////
// 对于http格式的请求和应答
// 例如 https://api.com/data/v1/api/master/getSecID.json?assetClass=E&exchangeCD=XSHE,XSHG
// fmt = http
// service = https://api.com/data/v1/api/master/ # 这里是链接的url 路由
// command = getSecID.json  # 这里是api的方法
// ask :{ assetClass: E, exchangeCD : "XSHE,XSHG", post:{...}, headers:{...}, ...}
//       # ask 中 如果有 post字段表示 post 方式 否则以get方式获取数据
//       # ask 中 如果有 headers字段表示 请求中国要增加 headers 字典中的内容
// ---- 应答时 解析http返回数据为 JSON 应答格式----
// 处理http流程：C端拼接标准json命令 传入中间件 如果fmt是http就解析为http请求包去获取数据
// 并解析返回数据为标准JSON应答格式数据提交给C端
//////////////////////////////////////////////////////////////////////////////////////////
// 解决代理数据传递的问题 - 类比于分布式数据传递机制
// C发送请求 O 增加一级 oname:cname:{} 后传递给 S
// S响应后 返回给 O ， O脱壳oname后 返回 :cname:{} 传递给 C
// 其中如果 C 的请求信息完全一致 O 代理层 会把返回的数据分发给相同请求的客户端
// 此时后续的C请求公用一个 oname
// 同时这也是解决分布式重复计算的方案
// 注意对于有分包数据返回或订阅数据返回 需要在O端保持一定时间的catch

// 阻塞直到有返回 超过 wait_msec 没有数据返回就超时退出
// int sis_net_class_ask_wait(s_sis_net_class *, s_sis_object *send_, s_sis_object *recv_);

/////////////////////////////////////////////////////////////
// 协议说明
/////////////////////////////////////////////////////////////
// 1、底层协议格式 以ws为基础协议 实际数据协议 二进制和JSON混杂格式两种
// 客户端发起连接 连接认证通过后,
// 客户端 发送 1:{ cmd:login, argv:{version : 1, compress : snappy, format: json, username : xxx, password : xxx}}
// 服务端 成功返回 1: { login : ok }
//       失败返回 1: { logout : "format 不支持."}
// 对回调没有要求的 不填来源 则包以:开头
// 所有标志符不能带 :

// 2、二进制协议格式 主要应用于快速数据交互
// 二进制协议交互 握手后 必须交互一次结构化数据的字典表
// 客户端凡事需要发送的二进制结构体都需要首先发送给服务端 并唯一命名 服务器亦然 以便对方能认识自己
// 客户端 发送 2: { cmd:dict, argv:{info:{fields:[[],[]]},market:{fields:[[],[]]},trade:{fields:[[],[]]}} }
// 服务端 发送 2: { cmd:dict, argv:{info:{fields:[[],[]]},market:{fields:[[],[]]},trade:{fields:[[],[]]}} }
// 之后客户端发送格式为 3:set:key:sdb:+..... 对应json的几个参数 key sdb

// 这些交互底层处理掉 上层收到的就是字符串数据

// 3、JSON协议格式 主要应用于 ws 协议下的web应用
// 基于json数据格式，通过驱动来转换数据格式，从协议层来说相当于底层协议的解释层，

// 格式说明：
// id: 以冒号为ID结束符，以确定信息的一一对应关系 不能有{}():符号
// {} json 数据 -- 字符串
// [] array 数据 -- 字符串

```
// sno  -- 谁干的事结果给谁 针对异步问题数据的对应关系问题 [必选]
// cmd -- 干什么 [必选]
// service -- 对谁干 [可选]
// subject -- 对什么属性干 [可选] 
// info -- 怎么干... [可选]
```

// 请求格式例子:
// 10001:{"service":"交易网关1","cmd":"下单","subject":"SH600601","info":{}}

// 应答格式例子:

10001:{"tag":0}

// info参数只能为数值、字符串，[],{}，必须能够被js解析，
// id:{"cmd":"sisdb.set","key":"sh600601","sdb":"info","argv":[{"time":100,"newp":100.01}]}

// 应答格式例子:
// id:{} 通常返回信息类查询
// id:[[],[]] 单key单sdb
// id:{"000001.info":[[],[]],"000002.info":[[],[]]} 多key或多sdb
// id:{"info.fields":[[],[]]} 返回字段信息 也可以混合在以上的返回结构

// id的意义如下：
// 	所有的消息都以字符串或数字为开始，以冒号为结束；
// 	system:为系统类消息，比如链接、登录、PING等信息；
// 	不放在{}中的原因是解析简单，快速定位转发
// 	1.作为转发中间件时，aaa.bbb.ccc的方式一级一级下去，返回数据后再一级一级上来，最后返回给发出请求的端口，
// 	  方便做分布式应用的链表；因为该值会有变化，和请求数据分开放置；只有内存拷贝没有json解析
// 	2.作为订阅和发布，当客户订阅了某一类数据，异步返回数据时可以准确的定位数据源，
// 	3.对于一应一答的阻塞请求，基本可以忽略不用；
//  4.对于客户端发出多个请求，服务端返回数据时以stock来定位请求；

### 正确的系统通讯处理

1、客户端 从网络收数据 接收到多少数据就直接 放入接收缓冲“写优先链表”CR中，应用层读CR解析后一条一条堵塞处理
向网络写数据 应用层传入数据 放入发送缓冲“写优先链表”CW中，网络层循环堵塞写直到CW为空
（如果发送剩余数据超过最大发送缓存大小或阀值，认为对端已死 直接断开连接重连）
服务端 从网络收数据 每个C收到多少数据先放入C对应的“写优先链表”CR中，应用层解析CR后 放入混合接收缓冲“写优先链表”SR中，
应用层读SR 然后一条一条处理
向客户写数据 应用层传入数据 放入发送缓冲“写优先链表”SW中，网络层循环堵塞（分块）写直到SW为空
分块是为了避免一个连接数据量太大影响其他客户的响应
（如果某客户发送剩余数据超过最大发送缓存大小或阀值，认为对端已死 直接断开连接）

以上情况下 仅仅在网络接收和发送时写入和读取链表时有锁，其他时候 即便是server也不会再有锁 保证任何时候都是单线程在访问应用层数据
SR - 多个用户的请求 混合为一个队列 然后逐条输出
CR - 原始数据 经过序列化 然后逐条输出
CW - 单用户写优先链表
SW - 多用户写优先链表 通常采用固定块轮询分块输出

读取的数据
只有写入数据
